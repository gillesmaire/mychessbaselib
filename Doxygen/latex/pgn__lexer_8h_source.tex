\hypertarget{pgn__lexer_8h_source}{}\doxysection{pgn\+\_\+lexer.\+h}
\mbox{\hyperlink{pgn__lexer_8h}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{1 \textcolor{comment}{/*}}
\DoxyCodeLine{2 \textcolor{comment}{ * Copyright (C) 2018  Fulvio Benini.}}
\DoxyCodeLine{3 \textcolor{comment}{ *}}
\DoxyCodeLine{4 \textcolor{comment}{ * Permission is hereby granted, free of charge, to any person obtaining a}}
\DoxyCodeLine{5 \textcolor{comment}{ * copy of this software and associated documentation files (the "{}Software"{}),}}
\DoxyCodeLine{6 \textcolor{comment}{ * to deal in the Software without restriction, including without limitation}}
\DoxyCodeLine{7 \textcolor{comment}{ * the rights to use, copy, modify, merge, publish, distribute, sublicense,}}
\DoxyCodeLine{8 \textcolor{comment}{ * and/or sell copies of the Software, and to permit persons to whom the}}
\DoxyCodeLine{9 \textcolor{comment}{ * Software is furnished to do so, subject to the following conditions:}}
\DoxyCodeLine{10 \textcolor{comment}{ *}}
\DoxyCodeLine{11 \textcolor{comment}{ * The above copyright notice and this permission notice shall be included}}
\DoxyCodeLine{12 \textcolor{comment}{ * in all copies or substantial portions of the Software.}}
\DoxyCodeLine{13 \textcolor{comment}{ *}}
\DoxyCodeLine{14 \textcolor{comment}{ * THE SOFTWARE IS PROVIDED "{}AS IS"{}, WITHOUT WARRANTY OF ANY KIND,}}
\DoxyCodeLine{15 \textcolor{comment}{ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF}}
\DoxyCodeLine{16 \textcolor{comment}{ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.}}
\DoxyCodeLine{17 \textcolor{comment}{ * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY}}
\DoxyCodeLine{18 \textcolor{comment}{ * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,}}
\DoxyCodeLine{19 \textcolor{comment}{ * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH}}
\DoxyCodeLine{20 \textcolor{comment}{ * THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.}}
\DoxyCodeLine{21 \textcolor{comment}{ */}}
\DoxyCodeLine{22 }
\DoxyCodeLine{27 \textcolor{preprocessor}{\#ifndef PGN\_LEXER\_H}}
\DoxyCodeLine{28 \textcolor{preprocessor}{\#define PGN\_LEXER\_H}}
\DoxyCodeLine{29 }
\DoxyCodeLine{30 \textcolor{preprocessor}{\#include <algorithm>}}
\DoxyCodeLine{31 \textcolor{preprocessor}{\#include <cassert>}}
\DoxyCodeLine{32 }
\DoxyCodeLine{33 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacepgn__impl}{pgn\_impl}} \{}
\DoxyCodeLine{34 \textcolor{comment}{// "{}PGN character data is organized as tokens. A token is a contiguous}}
\DoxyCodeLine{35 \textcolor{comment}{// sequence of characters that represents a basic semantic unit. Tokens}}
\DoxyCodeLine{36 \textcolor{comment}{// may be separated from adjacent tokens by white space characters.}}
\DoxyCodeLine{37 \textcolor{comment}{// (White space characters include space, newline, and tab characters.)}}
\DoxyCodeLine{38 \textcolor{comment}{// Some tokens are self delimiting and do not require white space}}
\DoxyCodeLine{39 \textcolor{comment}{// characters."{}}}
\DoxyCodeLine{40 }
\DoxyCodeLine{52 \textcolor{keyword}{constexpr} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} \mbox{\hyperlink{namespacepgn__impl_abbbc7b53ce12501f3641406e013af873}{init\_symbol\_map}}(\textcolor{keywordtype}{unsigned} elem) \{}
\DoxyCodeLine{53     \textcolor{keywordflow}{return} (elem == 0) ? 0x27ffb80800000000 : 0x47fffffe87ffffff;}
\DoxyCodeLine{54 }
\DoxyCodeLine{55     \textcolor{comment}{/* Requires gcc >= 6.2 or clang >= 3.5}}
\DoxyCodeLine{56 \textcolor{comment}{}}
\DoxyCodeLine{57 \textcolor{comment}{       unsigned long long res[2] = \{0\};}}
\DoxyCodeLine{58 \textcolor{comment}{       for (unsigned ch = 'A'; ch <= 'Z'; ++ch) \{}}
\DoxyCodeLine{59 \textcolor{comment}{           res[ch / 64] |= (1ULL << (ch \% 64));}}
\DoxyCodeLine{60 \textcolor{comment}{       \}}}
\DoxyCodeLine{61 \textcolor{comment}{       for (unsigned ch = 'a'; ch <= 'z'; ++ch) \{}}
\DoxyCodeLine{62 \textcolor{comment}{           res[ch / 64] |= (1ULL << (ch \% 64));}}
\DoxyCodeLine{63 \textcolor{comment}{       \}}}
\DoxyCodeLine{64 \textcolor{comment}{       for (unsigned ch = '0'; ch <= '9'; ++ch) \{}}
\DoxyCodeLine{65 \textcolor{comment}{           res[ch / 64] |= (1ULL << (ch \% 64));}}
\DoxyCodeLine{66 \textcolor{comment}{       \}}}
\DoxyCodeLine{67 \textcolor{comment}{       const unsigned extra[] = \{'\_', '+', '\#', '=', ':', '-\/'\};}}
\DoxyCodeLine{68 \textcolor{comment}{       for (unsigned ch : extra) \{}}
\DoxyCodeLine{69 \textcolor{comment}{           res[ch / 64] |= (1ULL << (ch \% 64));}}
\DoxyCodeLine{70 \textcolor{comment}{       \}}}
\DoxyCodeLine{71 \textcolor{comment}{       const unsigned drawresult\_unclear[] = \{'/', '\string~'\};}}
\DoxyCodeLine{72 \textcolor{comment}{       for (unsigned ch : drawresult\_unclear) \{}}
\DoxyCodeLine{73 \textcolor{comment}{           res[ch / 64] |= (1ULL << (ch \% 64));}}
\DoxyCodeLine{74 \textcolor{comment}{       \}}}
\DoxyCodeLine{75 \textcolor{comment}{       const unsigned chess\_variants[] = \{',', '@'\};}}
\DoxyCodeLine{76 \textcolor{comment}{       for (unsigned ch : chess\_variants) \{}}
\DoxyCodeLine{77 \textcolor{comment}{           res[ch / 64] |= (1ULL << (ch \% 64));}}
\DoxyCodeLine{78 \textcolor{comment}{       \}}}
\DoxyCodeLine{79 \textcolor{comment}{       return res[elem];}}
\DoxyCodeLine{80 \textcolor{comment}{   */}}
\DoxyCodeLine{81 \}}
\DoxyCodeLine{82 }
\DoxyCodeLine{88 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacepgn__impl_a256a08976dac501ca9453124d8cedec1}{is\_PGNsymbol}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} ch) \{}
\DoxyCodeLine{89     \textcolor{keyword}{constexpr} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} \textcolor{keywordtype}{long} tok\_map[] = \{\mbox{\hyperlink{namespacepgn__impl_abbbc7b53ce12501f3641406e013af873}{init\_symbol\_map}}(0),}
\DoxyCodeLine{90                                               \mbox{\hyperlink{namespacepgn__impl_abbbc7b53ce12501f3641406e013af873}{init\_symbol\_map}}(1)\};}
\DoxyCodeLine{91     \textcolor{keyword}{auto} high = ch / 64;}
\DoxyCodeLine{92     \textcolor{keyword}{auto} low = ch \% 64;}
\DoxyCodeLine{93     \textcolor{keywordflow}{return} high > 1 ? false : tok\_map[high] \& (1ULL << low);}
\DoxyCodeLine{94 \}}
\DoxyCodeLine{95 }
\DoxyCodeLine{101 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacepgn__impl_af173bdc1942df0cb0595fed31cce5f92}{is\_PGNdigit}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} ch) \{ \textcolor{keywordflow}{return} ch >= \textcolor{charliteral}{'0'} \&\& ch <= \textcolor{charliteral}{'9'}; \}}
\DoxyCodeLine{102 }
\DoxyCodeLine{109 \textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacepgn__impl_a5ecc45ec87d4aa8bc4a00e488591d9ab}{is\_PGNwhitespace}}(\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} ch) \{}
\DoxyCodeLine{110     \textcolor{keywordflow}{return} (ch == \textcolor{charliteral}{' '} || ch == \textcolor{charliteral}{'\(\backslash\)r'} || ch == \textcolor{charliteral}{'\(\backslash\)t'} || ch == \textcolor{charliteral}{'\(\backslash\)v'} || ch == \textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{111 \}}
\DoxyCodeLine{112 }
\DoxyCodeLine{127 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TView> \textcolor{keywordtype}{char} \mbox{\hyperlink{namespacepgn__impl_a45c4145fe058036514c11c8520641fb5}{is\_PGNtermination}}(TView tok) \{}
\DoxyCodeLine{128     \textcolor{keyword}{auto} n\_chars = std::distance(tok.first, tok.second);}
\DoxyCodeLine{129     \textcolor{keywordflow}{if} (n\_chars == 3) \{}
\DoxyCodeLine{130         \textcolor{keywordflow}{if} (std::equal(tok.first, tok.first + 3, \textcolor{stringliteral}{"{}1-\/0"{}}))}
\DoxyCodeLine{131             \textcolor{keywordflow}{return} \textcolor{charliteral}{'1'};}
\DoxyCodeLine{132         \textcolor{keywordflow}{if} (std::equal(tok.first, tok.first + 3, \textcolor{stringliteral}{"{}0-\/1"{}}))}
\DoxyCodeLine{133             \textcolor{keywordflow}{return} \textcolor{charliteral}{'0'};}
\DoxyCodeLine{134         \textcolor{keywordflow}{if} (std::equal(tok.first, tok.first + 3, \textcolor{stringliteral}{"{}1/2"{}}))}
\DoxyCodeLine{135             \textcolor{keywordflow}{return} \textcolor{charliteral}{'/'};}
\DoxyCodeLine{136         \textcolor{keywordflow}{if} (std::equal(tok.first, tok.first + 3, \textcolor{stringliteral}{"{}1:0"{}}))}
\DoxyCodeLine{137             \textcolor{keywordflow}{return} \textcolor{charliteral}{'1'};}
\DoxyCodeLine{138         \textcolor{keywordflow}{if} (std::equal(tok.first, tok.first + 3, \textcolor{stringliteral}{"{}0:1"{}}))}
\DoxyCodeLine{139             \textcolor{keywordflow}{return} \textcolor{charliteral}{'0'};}
\DoxyCodeLine{140     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (n\_chars == 7) \{}
\DoxyCodeLine{141         \textcolor{keywordflow}{if} (std::equal(tok.first, tok.first + 7, \textcolor{stringliteral}{"{}1/2-\/1/2"{}}) ||}
\DoxyCodeLine{142             std::equal(tok.first, tok.first + 7, \textcolor{stringliteral}{"{}1/2:1/2"{}}))}
\DoxyCodeLine{143             \textcolor{keywordflow}{return} \textcolor{charliteral}{'/'};}
\DoxyCodeLine{144     \}}
\DoxyCodeLine{145     \textcolor{keywordflow}{return} 0;}
\DoxyCodeLine{146 \}}
\DoxyCodeLine{147 }
\DoxyCodeLine{158 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TInput, \textcolor{keyword}{typename} TVisitor>}
\DoxyCodeLine{159 \textcolor{keywordtype}{bool} \mbox{\hyperlink{namespacepgn__impl_a7e328c869aeda69e2fad07d812136278}{parse\_token}}(\textcolor{keywordtype}{char} ch, TInput\& input, TVisitor\& parser, \textcolor{keywordtype}{int}\& section) \{}
\DoxyCodeLine{160     \textcolor{keywordflow}{switch} (ch) \{}
\DoxyCodeLine{161     \textcolor{keywordflow}{case} \textcolor{charliteral}{' '}:  \textcolor{comment}{// self terminating}}
\DoxyCodeLine{162     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)t'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{163     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)v'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{164     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)r'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{165         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{166 }
\DoxyCodeLine{167     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)n'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{168         \textcolor{keywordflow}{return} parser.visitPGN\_EndOfLine();}
\DoxyCodeLine{169 }
\DoxyCodeLine{170     \textcolor{keywordflow}{case} \textcolor{charliteral}{'.'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{171         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{172 }
\DoxyCodeLine{173     \textcolor{keywordflow}{case} \textcolor{charliteral}{'<'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{174         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{175 }
\DoxyCodeLine{176     \textcolor{keywordflow}{case} \textcolor{charliteral}{'>'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{177         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{178 }
\DoxyCodeLine{179     \textcolor{keywordflow}{case} \textcolor{charliteral}{'*'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{180         parser.visitPGN\_ResultFinal(\textcolor{charliteral}{'*'});}
\DoxyCodeLine{181         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{182 }
\DoxyCodeLine{183     \textcolor{keywordflow}{case} \textcolor{charliteral}{'('}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{184         \textcolor{keywordflow}{return} parser.visitPGN\_VariationStart();}
\DoxyCodeLine{185 }
\DoxyCodeLine{186     \textcolor{keywordflow}{case} \textcolor{charliteral}{')'}: \textcolor{comment}{// self terminating}}
\DoxyCodeLine{187         \textcolor{keywordflow}{return} parser.visitPGN\_VariationEnd();}
\DoxyCodeLine{188 }
\DoxyCodeLine{189     \textcolor{keywordflow}{case} \textcolor{charliteral}{'['}: \textcolor{comment}{// -\/-\/> ']', can span multiple lines}}
\DoxyCodeLine{190         \textcolor{keywordflow}{if} (section <= 0) \{}
\DoxyCodeLine{191             section = 0;}
\DoxyCodeLine{192             \textcolor{keyword}{auto} skip\_spaces = [\&]() \{}
\DoxyCodeLine{193                 \textcolor{keyword}{auto} spaces = input.read\_while(\mbox{\hyperlink{namespacepgn__impl_a5ecc45ec87d4aa8bc4a00e488591d9ab}{is\_PGNwhitespace}});}
\DoxyCodeLine{194                 \textcolor{keywordflow}{while} (spaces.first != spaces.second) \{}
\DoxyCodeLine{195                     \textcolor{keywordflow}{if} (*spaces.first++ == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{196                         parser.visitPGN\_EndOfLine();}
\DoxyCodeLine{197                 \}}
\DoxyCodeLine{198             \};}
\DoxyCodeLine{199             skip\_spaces();}
\DoxyCodeLine{200             \textcolor{keyword}{auto} tag = input.read\_while(\mbox{\hyperlink{namespacepgn__impl_a256a08976dac501ca9453124d8cedec1}{is\_PGNsymbol}});}
\DoxyCodeLine{201 }
\DoxyCodeLine{202             skip\_spaces();}
\DoxyCodeLine{203             \textcolor{keyword}{auto} value = input.read\_until(\textcolor{charliteral}{']'});}
\DoxyCodeLine{204 }
\DoxyCodeLine{205             \textcolor{comment}{// Remove the "{} char at the start and deal with the special case of}}
\DoxyCodeLine{206             \textcolor{comment}{// a ] char inside the string token.}}
\DoxyCodeLine{207             \textcolor{keywordflow}{if} (value.first != value.second \&\& *value.first == \textcolor{charliteral}{'"{}'}) \{}
\DoxyCodeLine{208                 \textcolor{keyword}{auto} is\_terminated = [\&]() \{}
\DoxyCodeLine{209                     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = value.first; it != value.second; ++it) \{}
\DoxyCodeLine{210                         \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'"{}'})}
\DoxyCodeLine{211                             \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{212                         \textcolor{keywordflow}{if} (*it == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} \&\& ++it == value.second)}
\DoxyCodeLine{213                             \textcolor{keywordflow}{break};}
\DoxyCodeLine{214                     \}}
\DoxyCodeLine{215                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{216                 \};}
\DoxyCodeLine{217                 ++value.first;}
\DoxyCodeLine{218                 \textcolor{keywordflow}{while} (!input.last\_column() \&\& !is\_terminated()) \{}
\DoxyCodeLine{219                     value.second = input.read\_until(\textcolor{charliteral}{']'}).second;}
\DoxyCodeLine{220                 \}}
\DoxyCodeLine{221             \}}
\DoxyCodeLine{222             \textcolor{comment}{// trim right}}
\DoxyCodeLine{223             \textcolor{keywordflow}{while} (value.first != value.second) \{}
\DoxyCodeLine{224                 \textcolor{keyword}{auto} last\_ch = *-\/-\/value.second;}
\DoxyCodeLine{225                 \textcolor{keywordflow}{if} (last\_ch == \textcolor{charliteral}{'"{}'}) \{}
\DoxyCodeLine{226                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{227                 \}}
\DoxyCodeLine{228                 \textcolor{keywordflow}{if} (!\mbox{\hyperlink{namespacepgn__impl_a5ecc45ec87d4aa8bc4a00e488591d9ab}{is\_PGNwhitespace}}(last\_ch)) \{}
\DoxyCodeLine{229                     ++value.second;}
\DoxyCodeLine{230                     \textcolor{keywordflow}{break};}
\DoxyCodeLine{231                 \}}
\DoxyCodeLine{232                 \textcolor{keywordflow}{if} (last\_ch == \textcolor{charliteral}{'\(\backslash\)n'})}
\DoxyCodeLine{233                     parser.visitPGN\_EndOfLine();}
\DoxyCodeLine{234             \}}
\DoxyCodeLine{235             \textcolor{keywordflow}{return} parser.visitPGN\_TagPair(tag, value);}
\DoxyCodeLine{236         \}}
\DoxyCodeLine{237         input.sungetc();}
\DoxyCodeLine{238         parser.visitPGN\_inputUnexpectedPGNHeader();}
\DoxyCodeLine{239         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{240 }
\DoxyCodeLine{241     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\{'}: \textcolor{comment}{// -\/-\/> '\}', can span multiple lines}}
\DoxyCodeLine{242         \textcolor{keywordflow}{return} parser.visitPGN\_Comment(input.read\_until(\textcolor{charliteral}{'\}'}));}
\DoxyCodeLine{243 }
\DoxyCodeLine{244     \textcolor{keywordflow}{case} \textcolor{charliteral}{';'}: \textcolor{comment}{// -\/-\/> '\(\backslash\)n'}}
\DoxyCodeLine{245         \textcolor{keywordflow}{return} parser.visitPGN\_Comment(input.read\_line());}
\DoxyCodeLine{246 }
\DoxyCodeLine{247     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\%'}: \textcolor{comment}{// -\/-\/> '\(\backslash\)n', only if "{}appearing in the first column of a line"{}}}
\DoxyCodeLine{248         \textcolor{keywordflow}{if} (input.first\_column()) \{}
\DoxyCodeLine{249             \textcolor{keywordflow}{return} parser.visitPGN\_Escape(input.read\_line());}
\DoxyCodeLine{250         \}}
\DoxyCodeLine{251         \textcolor{keywordflow}{return} parser.visitPGN\_Unknown(}
\DoxyCodeLine{252             input.read\_token([](\textcolor{keywordtype}{char} c) \{ return c == \textcolor{stringliteral}{'\%'}; \}));}
\DoxyCodeLine{253 }
\DoxyCodeLine{254     \textcolor{keywordflow}{case} \textcolor{charliteral}{'\$'}: \textcolor{comment}{// terminated just prior to the first non-\/digit character}}
\DoxyCodeLine{255         \textcolor{keywordflow}{return} parser.visitPGN\_NAG(input.read\_token(\mbox{\hyperlink{namespacepgn__impl_af173bdc1942df0cb0595fed31cce5f92}{is\_PGNdigit}}));}
\DoxyCodeLine{256 }
\DoxyCodeLine{257     \textcolor{keywordflow}{case} \textcolor{charliteral}{'?'}: \textcolor{comment}{// Suffix annotations: "{}!"{}, "{}?"{}, "{}!!"{}, "{}!?"{}, "{}?!"{}, and "{}??"{}}}
\DoxyCodeLine{258     \textcolor{keywordflow}{case} \textcolor{charliteral}{'!'}: \textcolor{comment}{// "{}At most one such suffix annotation may appear per move"{}}}
\DoxyCodeLine{259         \textcolor{keywordflow}{return} parser.visitPGN\_Suffix(}
\DoxyCodeLine{260             input.read\_token([](\textcolor{keywordtype}{char} c) \{ return c == \textcolor{stringliteral}{'!'} || c == \textcolor{stringliteral}{'?'}; \}));}
\DoxyCodeLine{261     \}}
\DoxyCodeLine{262 }
\DoxyCodeLine{263     \textcolor{comment}{// "{}A symbol token is terminated just prior to the first non-\/symbol}}
\DoxyCodeLine{264     \textcolor{comment}{// character following the symbol character sequence."{}}}
\DoxyCodeLine{265     \textcolor{keyword}{auto} tok = input.read\_token(\mbox{\hyperlink{namespacepgn__impl_a256a08976dac501ca9453124d8cedec1}{is\_PGNsymbol}});}
\DoxyCodeLine{266     \textcolor{keywordtype}{bool} epd = (section < 0 \&\& std::count(tok.first, tok.second, \textcolor{charliteral}{'/'}) == 7);}
\DoxyCodeLine{267     section = 1;}
\DoxyCodeLine{268 }
\DoxyCodeLine{269     \textcolor{keywordflow}{if} (epd) \{}
\DoxyCodeLine{270         tok.second = input.read\_line().second;}
\DoxyCodeLine{271         parser.visitPGN\_EPD(tok);}
\DoxyCodeLine{272         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{273     \}}
\DoxyCodeLine{274 }
\DoxyCodeLine{275     \textcolor{keyword}{auto} notdigit = std::find\_if\_not(tok.first, tok.second, \mbox{\hyperlink{namespacepgn__impl_af173bdc1942df0cb0595fed31cce5f92}{is\_PGNdigit}});}
\DoxyCodeLine{276     \textcolor{keywordflow}{if} (notdigit == tok.first)}
\DoxyCodeLine{277         \textcolor{keywordflow}{return} parser.visitPGN\_SANMove(tok);}
\DoxyCodeLine{278 }
\DoxyCodeLine{279     \textcolor{keywordflow}{if} (notdigit == tok.second)}
\DoxyCodeLine{280         \textcolor{keywordflow}{return} parser.visitPGN\_MoveNum(tok);}
\DoxyCodeLine{281 }
\DoxyCodeLine{282     \textcolor{keywordflow}{if} (\textcolor{keyword}{auto} result = \mbox{\hyperlink{namespacepgn__impl_a45c4145fe058036514c11c8520641fb5}{is\_PGNtermination}}(tok)) \{}
\DoxyCodeLine{283         parser.visitPGN\_ResultFinal(result);}
\DoxyCodeLine{284         \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{285     \}}
\DoxyCodeLine{286 }
\DoxyCodeLine{287     \textcolor{keywordflow}{return} parser.visitPGN\_Unknown(tok);}
\DoxyCodeLine{288 \}}
\DoxyCodeLine{289 }
\DoxyCodeLine{290 \textcolor{keyword}{class }\mbox{\hyperlink{classpgn__impl_1_1_input_memory}{InputMemory}} \{}
\DoxyCodeLine{291     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} begin\_;}
\DoxyCodeLine{292     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* \textcolor{keyword}{const} end\_;}
\DoxyCodeLine{293     \textcolor{keyword}{const} \textcolor{keywordtype}{char}* it\_;}
\DoxyCodeLine{294 }
\DoxyCodeLine{295 \textcolor{keyword}{public}:}
\DoxyCodeLine{296     \mbox{\hyperlink{classpgn__impl_1_1_input_memory_abe122c0c9ab8d33ce3329e18a8931478}{InputMemory}}(\textcolor{keyword}{const} \textcolor{keywordtype}{char}* begin, \textcolor{keyword}{const} \textcolor{keywordtype}{char}* end)}
\DoxyCodeLine{297         : begin\_(begin), end\_(end), it\_(begin) \{\}}
\DoxyCodeLine{298 }
\DoxyCodeLine{300     \textcolor{keywordtype}{char} \mbox{\hyperlink{classpgn__impl_1_1_input_memory_a389d50a5f67a20de865c9f8f79903798}{sbumpc}}() \{}
\DoxyCodeLine{301         assert(it\_ != end\_);}
\DoxyCodeLine{302         \textcolor{keywordflow}{return} *it\_++;}
\DoxyCodeLine{303     \};}
\DoxyCodeLine{304 }
\DoxyCodeLine{306     \textcolor{keywordtype}{void} \mbox{\hyperlink{classpgn__impl_1_1_input_memory_a79a3adda7580f580e58b50cc38b5995f}{sungetc}}() \{}
\DoxyCodeLine{307         assert(it\_ != begin\_ \&\& it\_ != end\_);}
\DoxyCodeLine{308         -\/-\/it\_;}
\DoxyCodeLine{309     \}}
\DoxyCodeLine{310 }
\DoxyCodeLine{312     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classpgn__impl_1_1_input_memory_a191e67b0f09068d88e6362b253bf9345}{eof}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} it\_ == end\_; \};}
\DoxyCodeLine{313 }
\DoxyCodeLine{315     std::size\_t \mbox{\hyperlink{classpgn__impl_1_1_input_memory_a673512f4f5e36a12c6d34d90c85d9bee}{n\_read}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} std::distance(begin\_, it\_); \}}
\DoxyCodeLine{316 }
\DoxyCodeLine{319     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classpgn__impl_1_1_input_memory_aa0eccd5c76a902949fd190a37af28a91}{first\_column}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} (\mbox{\hyperlink{classpgn__impl_1_1_input_memory_a673512f4f5e36a12c6d34d90c85d9bee}{n\_read}}() < 2 || *(it\_ -\/ 2) == \textcolor{charliteral}{'\(\backslash\)n'}); \};}
\DoxyCodeLine{320 }
\DoxyCodeLine{323     \textcolor{keywordtype}{bool} \mbox{\hyperlink{classpgn__impl_1_1_input_memory_ab76110aa769f11f5a60d2ef753ad420c}{last\_column}}()\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} \mbox{\hyperlink{classpgn__impl_1_1_input_memory_a191e67b0f09068d88e6362b253bf9345}{eof}}() || *it\_ == \textcolor{charliteral}{'\(\backslash\)n'} || *it\_ == \textcolor{charliteral}{'\(\backslash\)r'}; \}}
\DoxyCodeLine{324 }
\DoxyCodeLine{327     std::pair<const char*, const char*> \mbox{\hyperlink{classpgn__impl_1_1_input_memory_aa92c9ee19d0260c56034c1afc4659ce2}{read\_line}}() \{}
\DoxyCodeLine{328         \textcolor{keyword}{auto} first = it\_;}
\DoxyCodeLine{329         it\_ = \mbox{\hyperlink{namespace_d_base_pool_a9a065be391726006f9973ec733803167}{std::find}}(it\_, end\_, \textcolor{charliteral}{'\(\backslash\)n'});}
\DoxyCodeLine{330         \textcolor{keywordflow}{return} \{first, it\_\};}
\DoxyCodeLine{331     \}}
\DoxyCodeLine{332 }
\DoxyCodeLine{335     std::pair<const char*, const char*> \mbox{\hyperlink{classpgn__impl_1_1_input_memory_acb1000f14163f00c1f8a1fd9acf1b7b8}{read\_until}}(\textcolor{keywordtype}{char} delim) \{}
\DoxyCodeLine{336         \textcolor{keyword}{auto} first = it\_;}
\DoxyCodeLine{337         it\_ = \mbox{\hyperlink{namespace_d_base_pool_a9a065be391726006f9973ec733803167}{std::find}}(it\_, end\_, delim);}
\DoxyCodeLine{338         \textcolor{keyword}{auto} second = (it\_ == end\_) ? it\_ : it\_++;}
\DoxyCodeLine{339         \textcolor{keywordflow}{return} \{first, second\};}
\DoxyCodeLine{340     \}}
\DoxyCodeLine{341 }
\DoxyCodeLine{343     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Cond>}
\DoxyCodeLine{344     std::pair<const char*, const char*> \mbox{\hyperlink{classpgn__impl_1_1_input_memory_ab7c4ee9b828371722ae9c1d98bf7d851}{read\_while}}(Cond cond) \{}
\DoxyCodeLine{345         \textcolor{keyword}{auto} first = it\_;}
\DoxyCodeLine{346         it\_ = std::find\_if\_not(it\_, end\_, cond);}
\DoxyCodeLine{347         \textcolor{keywordflow}{return} \{first, it\_\};}
\DoxyCodeLine{348     \}}
\DoxyCodeLine{349 }
\DoxyCodeLine{352     \textcolor{keyword}{template} <\textcolor{keyword}{typename} Cond>}
\DoxyCodeLine{353     std::pair<const char*, const char*> \mbox{\hyperlink{classpgn__impl_1_1_input_memory_ab3a74870a4d284a833717905a75055ce}{read\_token}}(Cond cond) \{}
\DoxyCodeLine{354         assert(it\_ != begin\_);}
\DoxyCodeLine{355         \textcolor{keyword}{auto} first = it\_ -\/ 1;}
\DoxyCodeLine{356         it\_ = std::find\_if\_not(it\_, end\_, cond);}
\DoxyCodeLine{357         \textcolor{keywordflow}{return} \{first, it\_\};}
\DoxyCodeLine{358     \}}
\DoxyCodeLine{359 \};}
\DoxyCodeLine{360 }
\DoxyCodeLine{361 \} \textcolor{comment}{// namespace pgn\_impl}}
\DoxyCodeLine{362 }
\DoxyCodeLine{363 \textcolor{keyword}{namespace }\mbox{\hyperlink{namespacepgn}{pgn}} \{}
\DoxyCodeLine{364 }
\DoxyCodeLine{374 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TVisitor>}
\DoxyCodeLine{375 std::pair<std::size\_t, bool> \mbox{\hyperlink{namespacepgn_a98ee346a4a45c134c03aca8e18027a10}{parse\_game}}(\mbox{\hyperlink{classpgn__impl_1_1_input_memory}{pgn\_impl::InputMemory}} input,}
\DoxyCodeLine{376                                         TVisitor\&\& parser) \{}
\DoxyCodeLine{377     \textcolor{keywordtype}{int} section = -\/1;}
\DoxyCodeLine{378     \textcolor{keywordflow}{do} \{}
\DoxyCodeLine{379         \textcolor{keywordflow}{if} (input.\mbox{\hyperlink{classpgn__impl_1_1_input_memory_a191e67b0f09068d88e6362b253bf9345}{eof}}()) \{}
\DoxyCodeLine{380             \textcolor{keywordflow}{if} (section >= 0)}
\DoxyCodeLine{381                 parser.visitPGN\_inputEOF();}
\DoxyCodeLine{382             \textcolor{keywordflow}{break};}
\DoxyCodeLine{383         \}}
\DoxyCodeLine{384     \} \textcolor{keywordflow}{while} (\mbox{\hyperlink{namespacepgn__impl_a7e328c869aeda69e2fad07d812136278}{pgn\_impl::parse\_token}}(input.\mbox{\hyperlink{classpgn__impl_1_1_input_memory_a389d50a5f67a20de865c9f8f79903798}{sbumpc}}(), input, parser, section));}
\DoxyCodeLine{385 }
\DoxyCodeLine{386     \textcolor{keywordflow}{return} \{input.\mbox{\hyperlink{classpgn__impl_1_1_input_memory_a673512f4f5e36a12c6d34d90c85d9bee}{n\_read}}(), section >= 0\};}
\DoxyCodeLine{387 \}}
\DoxyCodeLine{388 }
\DoxyCodeLine{405 \textcolor{keyword}{template} <\textcolor{keywordtype}{bool} unescape = false, \textcolor{keyword}{typename} TString>}
\DoxyCodeLine{406 std::size\_t \mbox{\hyperlink{namespacepgn_a1e07b2abbe22fe845078799e17be260c}{normalize}}(TString\& str, std::size\_t pos) \{}
\DoxyCodeLine{407     std::size\_t n\_newlines = 0;}
\DoxyCodeLine{408     \textcolor{keywordflow}{for} (std::size\_t i = pos, n = str.size(); i < n; ++i) \{}
\DoxyCodeLine{409         \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} ch = str[i];}
\DoxyCodeLine{410         \textcolor{comment}{// An invalid UTF-\/8 sequence is considered a Latin1 char and converted.}}
\DoxyCodeLine{411         \textcolor{keywordflow}{if} (ch > 0xBF) \{}
\DoxyCodeLine{412             \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} nxt = (i + 1 != n) ? str[i + 1] : 0;}
\DoxyCodeLine{413             \textcolor{keywordflow}{if} (nxt < 0x80 || nxt > 0xBF) \{}
\DoxyCodeLine{414                 str[i] = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(ch \& 0xBF);}
\DoxyCodeLine{415                 str.insert(str.begin() + i, \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}\textcolor{keyword}{>}(0xC3));}
\DoxyCodeLine{416                 ++i;}
\DoxyCodeLine{417                 ++n;}
\DoxyCodeLine{418             \}}
\DoxyCodeLine{419         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{420             ++n\_newlines;}
\DoxyCodeLine{421         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (unescape \&\& ch == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} \&\& i + 1 != n) \{}
\DoxyCodeLine{422             \textcolor{comment}{// "{}A quote inside a string is represented by the backslash}}
\DoxyCodeLine{423             \textcolor{comment}{// immediately followed by a quote. A backslash inside a string is}}
\DoxyCodeLine{424             \textcolor{comment}{// represented by two adjacent backslashes."{}}}
\DoxyCodeLine{425             \textcolor{keywordflow}{if} (str[i + 1] == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'} || str[i + 1] == \textcolor{charliteral}{'"{}'}) \{}
\DoxyCodeLine{426                 str.erase(i, 1);}
\DoxyCodeLine{427                 -\/-\/n;}
\DoxyCodeLine{428             \}}
\DoxyCodeLine{429         \}}
\DoxyCodeLine{430     \}}
\DoxyCodeLine{431     \textcolor{keywordflow}{return} n\_newlines;}
\DoxyCodeLine{432 \}}
\DoxyCodeLine{433 }
\DoxyCodeLine{439 \textcolor{keyword}{template} <\textcolor{keyword}{typename} TView> std::size\_t \mbox{\hyperlink{namespacepgn_a4e6ca25094bbef4e4cf3239de1500616}{trim}}(TView\& str) \{}
\DoxyCodeLine{440     std::size\_t n\_newlines = 0;}
\DoxyCodeLine{441     \textcolor{keyword}{auto} is\_space = [\&n\_newlines](\textcolor{keywordtype}{char} ch) \{}
\DoxyCodeLine{442         \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'\(\backslash\)n'}) \{}
\DoxyCodeLine{443             ++n\_newlines;}
\DoxyCodeLine{444         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch != \textcolor{charliteral}{' '} \&\& ch != \textcolor{charliteral}{'\(\backslash\)r'} \&\& ch != \textcolor{charliteral}{'\(\backslash\)t'} \&\& ch != \textcolor{charliteral}{'\(\backslash\)v'}) \{}
\DoxyCodeLine{445             \textcolor{keywordflow}{return} \textcolor{keyword}{false};}
\DoxyCodeLine{446         \}}
\DoxyCodeLine{447         \textcolor{keywordflow}{return} \textcolor{keyword}{true};}
\DoxyCodeLine{448     \};}
\DoxyCodeLine{449     str.first = std::find\_if\_not(str.first, str.second, is\_space);}
\DoxyCodeLine{450 }
\DoxyCodeLine{451     \textcolor{keyword}{using }RevIt = std::reverse\_iterator<\textcolor{keyword}{decltype}(str.first)>;}
\DoxyCodeLine{452     str.second =}
\DoxyCodeLine{453         std::find\_if\_not(RevIt(str.second), RevIt(str.first), is\_space).base();}
\DoxyCodeLine{454 }
\DoxyCodeLine{455     \textcolor{keywordflow}{return} n\_newlines;}
\DoxyCodeLine{456 \}}
\DoxyCodeLine{457 }
\DoxyCodeLine{458 \} \textcolor{comment}{// namespace pgn}}
\DoxyCodeLine{459 }
\DoxyCodeLine{460 \textcolor{preprocessor}{\#endif }\textcolor{comment}{// PGN\_LEXER\_H}}

\end{DoxyCode}
